---
title: "Case-Control with Gestational Age Matching"
author:
  name: Christof Seiler
  affiliation: Department of Statistics, Stanford University
output:
  BiocStyle::html_document2:
    toc_float: true
params:
  treatment: "Mock"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Goal

1. Load and normalize data using ``oligo``
2. Differential analysis using ``limma``

# Prerequisites

Install necessary packages from bioconductor repository. Run this code only once to install packages.

```{r install_packages, warning=FALSE, message=FALSE}
pkgs_needed = c("oligo","limma","affycoretools","genefilter",
                "hta20transcriptcluster.db","ggfortify","magrittr",
                "statmod","stringr","tibble","dplyr")
letsinstall = setdiff(pkgs_needed, installed.packages()) 
if (length(letsinstall) > 0) {
  source("http://bioconductor.org/biocLite.R")
  biocLite(letsinstall)
}
```

Load packages.

```{r load_packages, warning=FALSE, message=FALSE}
library("oligo")
library("limma")
library("affycoretools")
library("genefilter")
library("hta20transcriptcluster.db")
library("ggfortify")
library("magrittr")
library("statmod")
library("stringr")
library("tibble")
library("dplyr")
```

# Import Data

Then load Affymetrix CEL files. At this stage, Bioconductor will automatically download the necessary annotation packages and install them for us. Add time to delivery variable.

```{r}
sample_table = read.csv("sample_table.csv")
cel_filenames = paste0(as.character(sample_table$array_name),".CEL")
sample_names = paste(sample_table$sample_id,
                     sample_table$condition,
                     sample_table$treatment,sep = "_")
sample_table %<>% filter(treatment == params$treatment)
sample_table$time_to_delivery = sample_table$gestage_delivery - 
  sample_table$gestage_enroll
pd = as(sample_table, "AnnotatedDataFrame")
rawData = read.celfiles(cel_filenames, phenoData = pd, 
                        sampleNames = sample_names)
rawData
```

# Preprocessing

Background subtraction, normalization and summarization using median-polish.

```{r}
eset = rma(rawData)
```

Get rid of background probes and annotate using functions in `affycoretools` package.

```{r affycoretools}
dbGetQuery(db(pd.hta.2.0), "select * from type_dict;")
table(getMainProbes("pd.hta.2.0")$type)
eset = getMainProbes(eset)
```

Filter probes that we cannot map to symbols.

```{r filter_probes}
e2s = toTable(hta20transcriptclusterSYMBOL)
prob_ids = rownames(exprs(eset))
keep_ids = which(prob_ids %in% e2s$probe_id)
eset = ExpressionSet(assayData = exprs(eset)[keep_ids,],
                     phenoData = phenoData(eset),
                     experimentData = experimentData(eset),
                     annotation = annotation(eset))
```

Save to file.

```{r save_eset}
class(eset)
show(eset)
exprs(eset)[1:10, 1:2]
save(eset,file = "eset.Rdata")
```

# Data Exploration

PCA plot of normalized expressions.

```{r}
res_pca = prcomp(t(exprs(eset)),scale. = FALSE)
screeplot(res_pca)
sample_table = eset@phenoData@data
asp_ratio = res_pca$sdev[2]^2/res_pca$sdev[1]^2
autoplot(res_pca, data = sample_table, colour = 'treatment', 
         shape = 'condition', size = 3, asp = asp_ratio)
sample_names = paste(sample_table$sample_id,
                     sample_table$treatment,sep = "_")
rownames(sample_table) = sample_names
autoplot(res_pca, data = sample_table, 
         shape = FALSE, label = TRUE, label.size = 3, asp = asp_ratio)
```

# Differential Expression Analyses

Use ``limma`` for linear models to assess difference in expression. Define design matrix.

```{r}
design = model.matrix(~ time_to_delivery + gestage_delivery, sample_table)
colnames(design) = str_replace(string = colnames(design),
                               pattern = ":",replacement = "_") %>%
  str_replace(string = .,pattern = "treatment",replacement = "")
colnames(design)
```

Automatic independent filtering: 

1. Estimate the correlation between measurements made on the same subject. 
2. Then this inter-subject correlation is input into the linear model fit. 
3. Then compute moderated t-tests.
4. The topTable command provides us a way of ranking genes for further evaluation. In the case below, we adjust for multiple testing by FDR. 

```{r paired_samples}
mean_expr = rowMeans(exprs(eset))
thres_candidates = seq(min(mean_expr),quantile(mean_expr, probs = 0.95),1)
fit_list = lapply(thres_candidates, function(thres) {
  cat("Automatic independent filtering: thres = ", thres,"\n")
  # threshold
  eset_thres = ExpressionSet(assayData = exprs(eset)[mean_expr >= thres,],
                             phenoData = phenoData(eset),
                             experimentData = experimentData(eset),
                             annotation = annotation(eset))
  # fit model
  fit = lmFit(eset_thres, design)
  eBayes(fit)
})
num_sig = sapply(fit_list, function(fit) {
  coeffs = colnames(design)[-1]
  gene_table_combined = lapply(coeffs,function(coeff_name) {
    gene_table = topTable(fit, coef = coeff_name, adjust="BH", 
                          number = nrow(fit))
    gene_table %>% dplyr::filter(adj.P.Val < 0.1) %>% 
      add_column(coeff = coeff_name)
  }) %>% bind_rows()
  nrow(gene_table_combined)
})
num_sig
fit = fit_list[[which.max(num_sig)]]
```

Save results in a list of tables.

```{r}
coeffs = colnames(design)[-1]
gene_table_list = lapply(coeffs, function(coeff_name) {
  gene_table = topTable(fit, 
                        coef = coeff_name, 
                        adjust="BH", 
                        number = nrow(fit))
  hist(gene_table$P.Value,breaks = 100,main = coeff_name)
  gene_table
})
names(gene_table_list) = coeffs
```

Volcano plots for quality control.

```{r}
for(coeff_name in coeffs) {
  cat(coeff_name,"\n")
  volcanoplot(fit,coef = coeff_name,highlight = 10)
}
```

Map between manufacturer identifiers and gene symbols.

```{r}
e2s = toTable(hta20transcriptclusterSYMBOL)
map_gene_symbol = function(gene_table) {
  prob_ids = rownames(gene_table)
  symbol = sapply(prob_ids,function(prob_id) {
    matching_symbol = e2s$symbol[prob_id==e2s$probe_id]
    if(length(matching_symbol)==0) matching_symbol = "No_Symbol_Found"
    matching_symbol
  }) %>% unlist
  gene_table = cbind(gene_table,symbol=symbol,stringsAsFactors=FALSE)
  gene_table
}
gene_table_list = lapply(gene_table_list,map_gene_symbol)
```

Print genes that are below an FDR of 0.1.

```{r}
for(i in 1:length(gene_table_list)) {
  separator = "-----------"
  cat(separator,names(gene_table_list)[i],separator,"\n")
  gene_table_subset = subset(gene_table_list[[i]],adj.P.Val < 0.1)
  print(gene_table_subset[,c("logFC","adj.P.Val","symbol")])
  cat(separator,names(gene_table_list)[i],separator,"\n\n")
}
```

Write to text file.

```{r}
for(i in 1:length(gene_table_list)) {
  file_name_results = paste0(names(gene_table_list)[i],"_results.csv")
  cat("writting:",file_name_results,"\n")
  write.csv(gene_table_list[[i]],file = file_name_results)
}
```

# Session Info {.unnumbered}

```{r session_info}
sessionInfo()
```
